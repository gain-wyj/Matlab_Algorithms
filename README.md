# Matlab_Algorithms
汇总matlab常用算法，针对每个算法有详细的源码

# 插值

插值法又称“内插法”，是利用函数f (x)在某区间中已知的若干点的函数值，作出适当的特定函数，在区间的其他点上用这特定函数的值作为函数f (x)的近似值，这种方法称为插值法。如果这特定函数是多项式，就称它为插值多项式。
 
 ## 线性插值
 
线性插值法是指使用连接两个已知量的直线来确定在这两个已知量之间的一个未知量的值的方法。

假设我们已知坐标(x0,y0)与(x1,y1),要得到[x0,x1]区间内某一位置x在直线上的值。根据图中所示，我们得到两点式直线方程：

![两点式直线方程](https://user-images.githubusercontent.com/58130973/114123825-b84fa880-9925-11eb-8b48-d43c276f2c5e.png)

![](https://user-images.githubusercontent.com/58130973/114123853-c3a2d400-9925-11eb-8d7a-7d4f7770aff3.png)

假设方程两边的值为α，那么这个值就是插值系数—从x0到x的距离与从x0到x1距离的比值。由于x值已知，所以可以从公式得到α的值：

![](https://user-images.githubusercontent.com/58130973/114123944-ee8d2800-9925-11eb-85c3-2ce2576da259.png)

同样：

![](https://user-images.githubusercontent.com/58130973/114123969-f8169000-9925-11eb-8f31-a8c6395f61ff.png)

这样，在代数上就可以表示成为：

y = (1 − α)y0 + αy1

或者，

y = y0 + α(y1 − y0)

这样通过α就可以直接得到 y。实际上，即使x不在x0到x1之间并且α也不是介于0到1之间，这个公式也是成立的。在这种情况下，这种方法叫作线性外插—参见 外插值。

已知y求x的过程与以上过程相同，只是x与y要进行交换。

## 拉格朗日插值

Language.m

## 埃米尔特插值

Hermite.m

如果要求插值函数不仅在节点处与函数同值，而且要求它与函数有相同的一阶、二阶甚至高阶导数值，这就是埃尔米特插值问题。

## 样条插值
所谓样条（ Spline）本来是工程设计中使用的一种绘图工具，它是富有弹性的细木条或细金属条。绘图员利用它把一些已知点连接成一条光滑曲线（称为样条曲线），并使连接点处有连续的曲率。数学上将具有一定光滑性的分段多项式称为样条函数。


# 函数逼近

多项式逼近：为复杂函数寻找近似替代多项式函数，其误差在某种度量意义下最小。（逼近只要求曲线接近型值点，符合型值点趋势）

# 矩阵特征值计算

关于这个特征值的求解一共六种方法
- 幂法
- 反幂法
- QR方法
- 对称QR方法
- jacobi方法
- 二分法

## 幂法

pmethod.m

输入:矩阵A、非零矢量x0、maxit(2000）、tol（1.0e-7)
输出：模的最大特征量a、模的最大特征量对应的特征向量x

## 反幂法

ipmethod.m

应用幂法于矩阵的反求矩阵的特征值

输入：矩阵A、非零矢量x0、maxit(2000）、tol（1.0e-7)
输出：模的最小特征量a、模的最小特征量对应的特征向量x

## QR方法

利用正交相似变换

输入:矩阵A、maxit(2000）、tol（1.0e-7)
输出：所有特征值、所有特征值所对应的特征向量

## 对称QR方法

输入：矩阵A、maxit(2000）、tol（1.0e-7)
输出：所有特征值、所有特征值所对应的特征向量

## jacobi方法

输入：矩阵A、maxit(2000）、tol（1.0e-7)
输出：模的最大特征量a、模的最大特征量对应的特征向量x

## 二分法

由两部分模块组成

第一部分

输入：矩阵A、maxit(2000）、tol（1.0e-7)
输出：所有特征值、所有特征值所对应的特征向量

第二部分

输入：A为非零矩阵,b0,b1为所求特征值所在的区间端点、tol（1.0e-7)
输出：所有特征值、所有特征值所对应的特征向量

# 数值微分与积分

## 微分

微分函数`diff(f，n)`函数,n代表对f求的阶数，这里的f既可以是个函数也可以是个矩阵。如果是个矩阵的话他就是对矩阵的元素求导。

只有一个变量x

`syms x;%`先定义一个变量x;

`f=sin(x);`%定义要求导的函数;

`diff(f);`%这就是对f求导函数

在进行微分时候，结果有时候需要化简可以用`simplify()`函数，若果式子里边含有分子和分母可以用`numden`这个函数，  `[a,b]=umden(f);`这个式子返回a为f 的分子，b返回f的分母。

## 积分

(1) 积分运算函数`int(f,x)`,这代表对f里的变量x求不定积分，

`int(f,x,a,b)`,这代表对f里的变量x求定积分。

`int(int(f,x),y)`，这样可以求二重积分，多层嵌套可以求多重积分。

注：`int()`函数可以计算解析解。

(2) `integral()`函数

`integral(f,a,b,'RelTol',1e-20,'Arrayvalued',true);`

函数f可以设置为函数句柄的形式（f一定是单变量的函数），a,b是对应的积分上下限，RelTol这个选项对应的就是设置误差限,在这里就相当于1e-20，ArrayValued的选项就是相当于允许向量化输入，比如f里面有a,x两个变量，对x进行积分，但是设置a=[1 2 3 ]这个向量时就必须设置这个选项否则结果报错！

# 方程求根

法一：

求方程的全部根

    在MATLAB命令窗口输入：
    p=[1,7,0,9,-20];   %建立多项式系数向量
    x=roots(p)         %求根

法二：

使用solve函数：

s=solve(f,v)：求方程关于指定自变量的解；

s=solve(f)：求方程关于默认自变量的解。

其中 f可以是用字符串表示的方程，或符号表达式；若f 中不含等号，则表示解 方程 f=0。

解方程 x^3-3*x+1=0

```
>>syms x; f=x^3-3*x+1;

>>s=solve(f,x)

>>s=solve(‘x^3-3*x+1’,‘x’)

>>s=solve(‘x^3-3*x+1=0’,‘x’)
```

Solve函数还可以用来求解方程组！

solve(f1,f2,...,fN,v1,v2,...,vN)

求解由 f1,f2,...,fN 确定的方程组关于 v1, v2,...,vN 的解。

解方程组：
```
>>[x,y,z]=solve(‘x+2*y-z=27’,‘x+z=3’, ...
                ‘x^2+3*y^2=28’,‘x’,‘y’,‘z’)
```
注意：输出变量的顺序要书写正确！

Solve在得不到解析解时，会给出数值解。

非线性方程组求解：

fzero(f,x0)：求方程f=0在x0附近的根。

几点说明：

方程可能有多个根，但是fzero只能给出距离x0最近的一个根；
若x0是一个标量，则fzero先找出一个包含x0的区间，使得f在这个区间两个端点上的值异号，然后再在这个区间内寻找方程f=0的根；如果找不到这样的区间，则返回NaN。
若x0是一个2维向量，则表示在[x0(1),x0(2)]区间内求方程的根，此时必须满足f在这两个端点上的值异号。
由于fzero是根据函数是否船业横轴来决定零点。因此它无法确定函数曲线仅触及横轴但是不穿越的零点，如|sin(x)|的所有零点。
函数中的f是一个函数句柄，通过以下方式给出：
字符串形式：fzero(‘x^3-3*x+1’,2);

通过@调用的函数句柄：fzero(@sin,4);

f不能用符号表达式！
 

线性方程组求解：

`linsolve(A,b)：解线性方程组`    
```
>> A=[1 2 –1; 1 0 1; 1 3 0];

>> b=[2;3;8];

>> X=linsolve(A,b)
```
注意这里的b是列向量。

求解方程函数小结

roots(p)：多项式的所有零点，p是多项式系数向量。

fzero(f,x0)：求f=0在x0附近的根，f是函数句柄，可以由字符串给出或使用@， 但不能是符号表达式！

solve(f,v)：求方程关于指定自变量的解，f可以是用字符串表示的方程，或符号表 达式，若不含等号表示f=0；

也可解方程组(包含非线性)；得不到解析解时，给出数值解。

linsolve(A,b)：解线性方程组。










